<#
.SYNOPSIS
  Generate Codex-friendly indexes for local docs trees.

.DESCRIPTION
  - Creates one `codex-index.md` per folder under RootDir that contains .md files.
  - Creates a RootIndexOutFile that lists all .md files recursively with short summaries.
  - Designed to keep upstream docs gitignored while keeping these index files tracked.

.NOTES
  Run with PowerShell 7+ (`pwsh`).
#>

param(
  [Parameter(Mandatory = $true)]
  [string]$RootDir,

  [Parameter(Mandatory = $true)]
  [string]$RootIndexOutFile,

  [Parameter(Mandatory = $true)]
  [string]$RootIndexTitle,

  [string]$IndexFileName = 'codex-index.md',

  [ValidateRange(0, 50)]
  [int]$MaxTopics = 6
)

$ErrorActionPreference = 'Stop'

function Write-Utf8NoBom {
  param(
    [Parameter(Mandatory = $true)][string]$Path,
    [Parameter(Mandatory = $true)][string]$Content
  )

  $utf8NoBom = New-Object System.Text.UTF8Encoding($false)
  $normalized = $Content.Replace("`r`n", "`n")
  [IO.File]::WriteAllText($Path, $normalized, $utf8NoBom)
}

function To-PosixPath {
  param([Parameter(Mandatory = $true)][string]$Path)
  return ($Path -replace '\\', '/')
}

function Get-RelativePath {
  param(
    [Parameter(Mandatory = $true)][string]$FromDirectoryAbs,
    [Parameter(Mandatory = $true)][string]$ToPathAbs
  )

  $from = [IO.Path]::GetFullPath($FromDirectoryAbs)
  $to = [IO.Path]::GetFullPath($ToPathAbs)

  if (-not $from.EndsWith([IO.Path]::DirectorySeparatorChar)) {
    $from += [IO.Path]::DirectorySeparatorChar
  }

  $fromUri = [Uri]$from
  $toUri = [Uri]$to
  $relative = $fromUri.MakeRelativeUri($toUri).ToString()
  $relative = [Uri]::UnescapeDataString($relative)

  return (To-PosixPath $relative)
}

function Find-GitRoot {
  param([Parameter(Mandatory = $true)][string]$StartDirectoryAbs)

  $dir = [IO.Path]::GetFullPath($StartDirectoryAbs)
  while ($true) {
    if (Test-Path -LiteralPath (Join-Path $dir '.git')) {
      return $dir
    }

    $parent = Split-Path -Path $dir -Parent
    if ([string]::IsNullOrWhiteSpace($parent) -or $parent -eq $dir) {
      return $null
    }

    $dir = $parent
  }
}

function Normalize-HeadingText {
  param([AllowNull()][string]$Text)

  if ($null -eq $Text) {
    return ''
  }

  $t = $Text.Trim()

  # Strip trailing ATX closing hashes (e.g. "## Heading ##")
  $t = $t -replace '\s*#+\s*$', ''

  # Remove Slidev Badge tags but keep their inner text.
  $t = $t -replace '</?Badge[^>]*>', ''

  # Strip trailing explicit anchor IDs (e.g. "{#dev}")
  $t = $t -replace '\s*\{#[-\w]+\}\s*$', ''

  # Replace Markdown links with their labels: [label](url) -> label
  $t = [regex]::Replace(
    $t,
    '\[(?<label>(?:\\.|[^\]])+)\]\((?<url>[^\)]*)\)',
    { param($m) $m.Groups['label'].Value }
  )

  # Unescape literal brackets in labels (e.g. "\\[08/2025\\]" -> "[08/2025]")
  $t = $t -replace '\\\[', '['
  $t = $t -replace '\\\]', ']'

  # Collapse whitespace
  $t = ($t -replace '\s+', ' ').Trim()

  return $t
}

function Get-MarkdownInfo {
  param(
    [Parameter(Mandatory = $true)][string]$FileAbs,
    [Parameter(Mandatory = $true)][int]$MaxTopics
  )

  $raw = Get-Content -LiteralPath $FileAbs -Raw -Encoding utf8
  $lines = $raw -split "`r?`n"

  $inCodeFence = $false
  $title = $null
  $topics = New-Object System.Collections.Generic.List[string]

  foreach ($line in $lines) {
    if ($line -match '^\s*```') {
      $inCodeFence = -not $inCodeFence
      continue
    }

    if ($inCodeFence) {
      continue
    }

    # Ignore blockquotes (autogenerated warnings etc.)
    if ($line -match '^\s*>') {
      continue
    }

    if (-not $title -and $line -match '^\s*#(?!#)\s+(.+)$') {
      $title = Normalize-HeadingText $matches[1]
      continue
    }

    if ($line -match '^\s*##(?!#)\s+(.+)$') {
      $topic = Normalize-HeadingText $matches[1]
      if (-not [string]::IsNullOrWhiteSpace($topic)) {
        $topics.Add($topic)

        if ($topics.Count -ge $MaxTopics -and -not [string]::IsNullOrWhiteSpace($title)) {
          break
        }
      }
    }
  }

  if ([string]::IsNullOrWhiteSpace($title)) {
    $title = [IO.Path]::GetFileNameWithoutExtension($FileAbs)
  }

  # De-dupe topics while preserving order.
  $seen = @{}
  $unique = New-Object System.Collections.Generic.List[string]
  foreach ($topic in $topics) {
    if (-not $seen.ContainsKey($topic)) {
      $seen[$topic] = $true
      $unique.Add($topic)
    }
  }

  return [pscustomobject]@{
    Title = $title
    Topics = $unique
  }
}

function Format-DocSummary {
  param(
    [Parameter(Mandatory = $true)][pscustomobject]$Info
  )

  if ($Info.Topics.Count -gt 0) {
    return "$($Info.Title) — $($Info.Topics -join ' / ')"
  }

  return "$($Info.Title)"
}

$rootDirAbs = [IO.Path]::GetFullPath($RootDir)
if (-not (Test-Path -LiteralPath $rootDirAbs)) {
  throw "RootDir not found: $RootDir"
}

$rootIndexOutAbs = [IO.Path]::GetFullPath($RootIndexOutFile)
$rootIndexOutDirAbs = Split-Path -Path $rootIndexOutAbs -Parent
if (-not (Test-Path -LiteralPath $rootIndexOutDirAbs)) {
  throw "RootIndexOutFile directory not found: $rootIndexOutDirAbs"
}

$repoRootAbs = Find-GitRoot $rootDirAbs
if ($null -eq $repoRootAbs) {
  throw "Could not find .git above: $rootDirAbs"
}

# Enumerate markdown files under RootDir, excluding generated index files.
$allMdFiles = Get-ChildItem -LiteralPath $rootDirAbs -Recurse -File -Filter '*.md' |
  Where-Object { $_.Name -ne $IndexFileName }

# Determine which directories need an index: every directory that contains .md files (and their ancestors).
$dirSet = New-Object System.Collections.Generic.HashSet[string]([StringComparer]::OrdinalIgnoreCase)
foreach ($file in $allMdFiles) {
  $dir = $file.Directory.FullName
  while ($true) {
    $null = $dirSet.Add($dir)

    if ($dir -ieq $rootDirAbs) {
      break
    }

    $parent = Split-Path -Path $dir -Parent
    if ([string]::IsNullOrWhiteSpace($parent) -or $parent -eq $dir) {
      break
    }

    $dir = $parent
  }
}

$indexDirs = $dirSet | Sort-Object

# Precompute recursive md-counts for folder listings.
$recursiveMdCountByDir = @{}
foreach ($dir in $indexDirs) {
  $recursiveMdCountByDir[$dir] = 0
}

foreach ($file in $allMdFiles) {
  $dir = $file.Directory.FullName
  while ($true) {
    if ($recursiveMdCountByDir.ContainsKey($dir)) {
      $recursiveMdCountByDir[$dir] = [int]$recursiveMdCountByDir[$dir] + 1
    }

    if ($dir -ieq $rootDirAbs) {
      break
    }

    $parent = Split-Path -Path $dir -Parent
    if ([string]::IsNullOrWhiteSpace($parent) -or $parent -eq $dir) {
      break
    }

    $dir = $parent
  }
}

# Markdown summary cache (avoid re-reading the same file).
$markdownInfoCache = @{}
function Get-MarkdownInfoCached {
  param([Parameter(Mandatory = $true)][string]$FileAbs)

  if ($markdownInfoCache.ContainsKey($FileAbs)) {
    return $markdownInfoCache[$FileAbs]
  }

  $info = Get-MarkdownInfo -FileAbs $FileAbs -MaxTopics $MaxTopics
  $markdownInfoCache[$FileAbs] = $info
  return $info
}

# 1) Generate per-folder codex-index.md
foreach ($dirAbs in $indexDirs) {
  $displayDir = To-PosixPath (Get-RelativePath -FromDirectoryAbs $repoRootAbs -ToPathAbs $dirAbs)

  $indexFileAbs = Join-Path $dirAbs $IndexFileName

  if ($dirAbs -ieq $rootDirAbs) {
    $parentTargetAbs = $rootIndexOutAbs
  }
  else {
    $parentDirAbs = Split-Path -Path $dirAbs -Parent
    $parentTargetAbs = Join-Path $parentDirAbs $IndexFileName
  }

  $parentLink = Get-RelativePath -FromDirectoryAbs $dirAbs -ToPathAbs $parentTargetAbs

  $lines = New-Object System.Collections.Generic.List[string]
  $lines.Add("# Codex Index: $displayDir")
  $lines.Add('')
  $lines.Add('Generated for quick navigation from Codex. Do not edit by hand.')
  $lines.Add('')
  $lines.Add("- Parent: [$parentLink]($parentLink)")
  $lines.Add('')

  # Subfolders
  $lines.Add('## Subfolders')
  $subdirs = Get-ChildItem -LiteralPath $dirAbs -Directory | Sort-Object Name
  $subdirLines = @()
  foreach ($subdir in $subdirs) {
    if (-not $dirSet.Contains($subdir.FullName)) {
      continue
    }

    $subdirIndexAbs = Join-Path $subdir.FullName $IndexFileName
    $subdirLink = Get-RelativePath -FromDirectoryAbs $dirAbs -ToPathAbs $subdirIndexAbs
    $mdCount = $recursiveMdCountByDir[$subdir.FullName]
    $subdirLines += "- $($subdir.Name)/ (md: $mdCount) -> [$IndexFileName]($subdirLink)"
  }

  if ($subdirLines.Count -eq 0) {
    $lines.Add('- (none)')
  }
  else {
    foreach ($l in $subdirLines) { $lines.Add($l) }
  }

  $lines.Add('')

  # Files (direct children)
  $lines.Add('## Files')
  $files = Get-ChildItem -LiteralPath $dirAbs -File -Filter '*.md' |
    Where-Object { $_.Name -ne $IndexFileName } |
    Sort-Object Name

  if ($files.Count -eq 0) {
    $lines.Add('- (none)')
  }
  else {
    foreach ($file in $files) {
      $info = Get-MarkdownInfoCached -FileAbs $file.FullName
      $summary = Format-DocSummary -Info $info
      $fileName = $file.Name
      $lines.Add("- [$fileName]($fileName) — $summary")
    }
  }

  $lines.Add('')

  Write-Utf8NoBom -Path $indexFileAbs -Content ($lines -join "`n")
}

# 2) Generate root index (docs/mermaid.md, docs/slidev.md)
$rootDirDisplay = To-PosixPath (Get-RelativePath -FromDirectoryAbs $repoRootAbs -ToPathAbs $rootDirAbs)
$entryIndexAbs = Join-Path $rootDirAbs $IndexFileName

$rootIndexLines = New-Object System.Collections.Generic.List[string]
$rootIndexLines.Add("# $RootIndexTitle")
$rootIndexLines.Add('')
$rootIndexLines.Add("- Docs folder (gitignored): ``$rootDirDisplay/``")
$rootIndexLines.Add("- Folder indexes: ``$rootDirDisplay/**/$IndexFileName``")

$entryLabel = To-PosixPath (Get-RelativePath -FromDirectoryAbs $repoRootAbs -ToPathAbs $entryIndexAbs)
$entryLink = Get-RelativePath -FromDirectoryAbs $rootIndexOutDirAbs -ToPathAbs $entryIndexAbs
$rootIndexLines.Add("- Entry: [$entryLabel]($entryLink)")
$rootIndexLines.Add('')

# Top-level folders
$rootIndexLines.Add('## Top-level folders')
$topSubdirs = Get-ChildItem -LiteralPath $rootDirAbs -Directory | Sort-Object Name
foreach ($subdir in $topSubdirs) {
  if (-not $dirSet.Contains($subdir.FullName)) {
    continue
  }

  $subdirIndexAbs = Join-Path $subdir.FullName $IndexFileName
  $subdirLabel = To-PosixPath (Get-RelativePath -FromDirectoryAbs $repoRootAbs -ToPathAbs $subdirIndexAbs)
  $subdirLink = Get-RelativePath -FromDirectoryAbs $rootIndexOutDirAbs -ToPathAbs $subdirIndexAbs
  $mdCount = $recursiveMdCountByDir[$subdir.FullName]
  $rootIndexLines.Add("- $($subdir.Name)/ (md: $mdCount) -> [$subdirLabel]($subdirLink)")
}

$rootIndexLines.Add('')

# All files
$rootIndexLines.Add('## All files (recursive)')
$rootIndexLines.Add("- Files: $($allMdFiles.Count)")
$rootIndexLines.Add('')

$sortedFiles = $allMdFiles | Sort-Object FullName
foreach ($file in $sortedFiles) {
  $label = To-PosixPath (Get-RelativePath -FromDirectoryAbs $repoRootAbs -ToPathAbs $file.FullName)
  $link = Get-RelativePath -FromDirectoryAbs $rootIndexOutDirAbs -ToPathAbs $file.FullName
  $info = Get-MarkdownInfoCached -FileAbs $file.FullName
  $summary = Format-DocSummary -Info $info
  $rootIndexLines.Add("- [$label]($link) — $summary")
}

$rootIndexLines.Add('')
$rootIndexLines.Add('## How to use (context saving)')
$rootIndexLines.Add('1. Open the Entry link')
$rootIndexLines.Add('2. Jump to a subfolder index')
$rootIndexLines.Add('3. Open the referenced .md file when needed')
$rootIndexLines.Add('')
$rootIndexLines.Add('Generated by: `scripts/generate-docs-index.ps1`')
$rootIndexLines.Add('')

Write-Utf8NoBom -Path $rootIndexOutAbs -Content ($rootIndexLines -join "`n")
